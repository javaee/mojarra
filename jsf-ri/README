This README documents the Sun Reference implementation (RI) for JSR 127,
JavaServer (tm) Faces.

jsf-api cvs tag for this implementation: JSF_API_20030924B
jsf-api-spec for this implementation: JSF_20030930.pdf

Installation Notes
==================

JavaServer (tm) Faces is intended to run in a Servlet 2.3, JSP 1.2 web
container, such as that distributed with Java Web Services Developer
Pack <http://java.sun.com/webservices/webservicespack.html>.  Please
follow the instructions for your container and have it working well in
your environment before continuing with these installation notes.

To use JavaServer (tm) Faces in your own webapp, you need to follow the
online documentation at <http://java.sun.com/j2ee/javaserverfaces/>.
Make sure to include all the jars in the lib directory of this
distribution in your WEB-INF/lib directory in your webapp.  

Major changes/features in this release:
=======================================

SECTION: API Changes by scarab issue

    JSFA92 

      * Add requirements for <f:subview/> tag.

      * Remove "lenient" attribute from <f:convert_datetime/>.

      * Miscellaneous cleanups (see change bars).

      SPEC IMPACT: Needs to have "lenient" property removed from Section
      3.3.3 if it was added (Ed, can you double check this?).

      RI IMPACT: Remove "lenient" attribute from the TLD and
      implementation class for the <f:convert_datetime> tag.

      DEMO IMPACT: All date/time parsing must strictly match the
      specified pattern.

      RI IMPACT:

      * Implement new tag for <f:subview/>

      * Relax the current TLV so that, if you are nested inside a naming
	container tag that is inside a conditional or iterator, you need
	not have an id.

      * Review change bars in Chapter 9 carefully for current compliance and/or
	problems where the spec is not complete enough.

      * Remove the long-ago deprecated FacesTag and FacesBodyTag classes
	that were replaced by UIComponentTag and UIComponentBodyTag.

   JSFA98

    Clarify responsibilities of methods on RenderKit and
    RenderKitFactory to be more consistent with other factories like
    Applicaton.

    M src/javax/faces/render/RenderKit.java

    - addRenderer() can repace existing Renderers for the same identifier.

    - getRenderer() returns null instead of IAE if no Renderer is registered
      for the specified type.

    - getResponseStream() renamed to createResponseStream() for consistency
      with createResponseWriter().


    M src/javax/faces/render/RenderKtFactory.java

    - addRenderKit() can replace existing RenderKits for the same identifier.

    - getRenderKit() returns null instead of IAE of no RenderKit is registered
      for the specified identifier.  The first form (taking only a
      renderKitId) must return an application-wide singeton; the second
      form (customized by a FacesContext) need not.

    RI IMPACTS:

    - Modify implementation of RenderKitImpl and RenderKitFactoryImpl
      to reflect the revised responsibilities.

    - Update unit tests to reflect ability to replace existing RenderKits and
      Renderers, and null-returns on unknown identifiers.

   JSFA80/106

      * Require that StateManager saves and restores the current Locale
	from/to the FacesContext.

   JSFA101

      we now have a tool that generates the concrete html components in
      the package javax.faces.component.html from meta-data in the
      standard-html-renderkit.xml file.  This tool will be expanded to
      generate the TLD and tag handler classes as well.

      The spec now includes a standard-html-renderkit.xml file, which is
      a faces-config file that defines the standard html renderkit.


    JSFA116

      * <jsp:include> and <c:import> now work.

    JSFA120

      Implement the API-related changes for queueing events and have
      them bubble up to the UIViewRoot (unless intercepted or modified
      by some component in between the source component and the tree
      root).

    JSFA121

      Make the code that parses the faces-config.xml install any
      phase-listener instances it finds.

      Add phase-listener syntax to DTD.

      RI Impact:

      The digester rules need to change to cause a PhaseListener to be
      added when a <phase-listener> element is encountered in the
      faces-config.xml file.

    JSFA122

      M src/javax/faces/component/UISelectMany.java

      - document that valueRefs for UISelectMany may also support "List of
	String".
    
    JSFA123

      RI and Demo Impact: any place that implements 

      UIComponent.decode() or UIComponent.processDecodes() will have to
      remove the "throws IOException" statement.
				    
    JSFA22 

      Remove the setComponent() method from StateHolder.  Move the
      responsibility of letting your attached object know about yourself to be
      the responsibility of the attachee.  For example, for things that have a
      ValueHolderSupport, such as UIOutputBase, they must manually call
      setComponent() on the ValueHolderSupport instance.

      DataGrid now works with save state in client or on server.
      Previously it only worked on server.

      Bugfix to correctly handle UIComponentBase.getAttributes() special
      attribute/property transparency map.

    JSFA76

      FormRenderer.encode() must render a hidden field with the name being
      the clientId of the UIForm component.  The value is inconsequential,
      but may need to be non-null.  Not sure.  Whatever you need to do to
      make the below logic in decode() work.

      FormRenderer.decode() must check
      RequestParameterMap.containsKey(clientId).  If so, it must call
      UIForm.setSubmitted(true).  Because we rendered a hidden field in
      encode, this will only happen to be the case if this is the form that
      was submitted.

    JSFA115

      Per EG discussion, we decided to add back two convenience methods
      that can be used for efficiency, because they avoid allocating the
      underlying List or Map if it's not already there:

      * public int getChildCount();

      * public UIComponent getFacet(String name);

      RI IMPACT: No *required* changes, but code that currently calls
      component.getChildren().size() or component.getFacets().get("...")
      should be revised to use the new method signatures (for
      readability as well as potential performance improvement).

      [JSFA115] For symmetry with the way that children and facets are
      handled, replace all the attribute-related methods with a
      getAttributes() that returns a mutable Map.

      RI IMPACT: Replace all the getAttribute(), getAttributeNames(),
      and setAttribute() calls with corresponding sequences.

      DEMO IMPACT: Same as RI IMPACT.

      NOTE: I tagged the jsf-api repository just before this commit with
      tag "JSF_API_20030919_BEFORE_ATTRIBUTES" if you want to be latest
      and greatest before this change that breaks compiling -- I did
      some bugfixes.

      [JSFA115] Switching to behavioral interfaces like ValueHolder has
      introduced some duplicate logic in the component classes that used
      to extend UIOutput.  It makes sense to create a support class to
      which these component classes can delegate the required behavior,
      in the same way that components implementing NamingContainer can
      delegate to NamingContainerSupport.

      [JSFA115] Flesh out ValueHolderSupport, including its support for
      saving and restoring its own state as an attached object.

      [JSFA115] Make all components that implement ValueHolder delegate
      this functionality to an instance of ValueHolderSupport, and make
      sure this instance variable is saved and restored as an attached
      object.

      [JSFA115] Add a new test case in ValueHolderTestCaseBase that
      ensures all of the properties reflected in the ValueHolder
      interface (including a precisely configured Converter instance)
      are correctly saved and restored.  This test is inherited by all
      of the component test cases for components that implement
      ValueHolder, so saving/restoring the attached object will be
      tested in all of those cases.

      [JSFA115] Bugfix.  getChildren().set() would fail if an old child
      was being replaced with a new one that has the same "id".  The
      check for validateMissing() here is superfluous, because the old
      component will be removed if it is present.

      [JSFA115] Unit test updates for transition back to concrete
      component classes.  See next commit message for detailed impacts.

      [JSFA115] Switch generic components back to concrete classes;
      eliminate the javax.faces.component.base package.

      RI IMPACT:

      * Change jsf-ri-config.xml to register the revised concrete
        component classes.

      * Change unit tests that instantiate concrete components.

      DEMO IMPACT:

      * Change inheritance of any demo-level component class that
        inherits from
	a concrete Faces base class.

   TCK related changes

     RI Impact: FacesContext Impl needs to throw IllegalStateException from
     every FacesContext method (except release()) if any method is called
     after release() is called.  That's all for now, since our RI doesn't
     recycle FacesContext instances.

     State that the implementation of FacesContext.release() must call
     setCurrentInstance(null).

   JSFA119

     RI Impact: I think this will break some of our lifecycle tests.  Also, I
     think we're going to want to change the exception we catch in
     UpdateModelValuesPhase to be RuntimeException.

     M src/javax/faces/component/UIComponent.java

     - Spec that if a RuntimeException is thrown during decode, validation,
       or update model processing, it is caught, renderResponse() is called,
       and the exception is re-thrown.

     M src/javax/faces/component/base/UIComponentBase.java

     - implement the above behavior

   JSFA110/JSFA42

     M src/javax/faces/application/ViewHandler.java

     +     * <p>The default implementation of <code>restoreView</code>
     +     * must examine the deployment descriptor for this web
     +     * application to determine the manner in which the {@link
     +     * javax.faces.webapp.FacesServlet} has been mapped to
     +     * incoming urls.  If prefix mapping is used, this method
     +     * simply calls {@link
     +     * javax.faces.context.ExternalContext#dispatchMessage}
     +     * passing the <code>viewId</code> of the argument
     +     * <code>viewToRender</code>.  If suffix mapping is used, the
     +     * default implementation must check the the servlet context
     +     * init parameter named by the value of the constant {@link
     +     * #DEFAULT_SUFFIX_PARAM_NAME}.  If this parameter is not
     +     * defined, use {@link #DEFAULT_SUFFIX} as the suffix.  Append
     +     * the suffix to the <code>viewId</code> of the argument
     +     * <code>viewToRender</code>, and call {@link
     +     * javax.faces.context.ExternalContext#dispatchMessage} on the
     +     * result.</p>

     and new method:

     +    /**
     +     * <p>Returns the context relative path of the argument
     +     * <code>viewId</code>, including any <code>url-pattern</code>
     +     * prefix mapping defined by the application.</p>
     +     *
     +     * <p>The default implementation must examine the deployment
     +     * descriptor for the current webapp and determine the
     +     * <code>url-pattern</code> mapping given for the {@link
     +     * javax.faces.webapp.FacesServlet}.  If the mapping is a
     +     * prefix mapping, prepend the prefix mapping to the viewId,
     +     * making sure to take any wildcards into account.  If the
     +     * mapping is an extension mapping, take no action and just
     +     * return the argument <code>viewId</code>.  The default
     +     * implementation expects the argument <code>viewId</code> to
     +     * be a context relative path, starting with '<code>/</code>'.
     +     * If this is not the case, the default implementation thows
     +     * <code>IllegalArgumentException</code>.</p>
     +     *
     +     * @param context the {@link FacesContext} for this request.
     +     *
     +     * @param viewId the context relative path of this viewId.
     +     *
     +     * @exception NullPointerException if <code>context</code> or
     +     * <code>viewId</code> is <code>null</code>.
     +     *
     +     * @exception IllegalArgumentException if <code>viewId</code> is not
     +     * valid for this <code>ViewHandler</code>.
     +     *
     +     */

     +    public String getViewIdPath(FacesContext context, String viewId);

     M src/javax/faces/context/ExternalContext.java

     - remove 

	public abstract String encodeURL(String url);

   JSFA3

     M src/javax/faces/application/ViewHandler.java

     - add component id uniqueness checking to the ViewHandler.renderView's list of
       things to do.

     M src/javax/faces/component/NamingContainer.java

      - remove all methods

      - update SEPARATOR_CHAR

     R src/javax/faces/component/NamingContainerSupport.java

     - remove this class.

     M src/javax/faces/component/UIComponent.java

     - remove SEPARATOR_CHAR, defined on NamingContainer

     - change getClientId() 

	In particular, change
	 UIComponentBase.getClientId(FacesContext)
       to always generate the client ID as it does in the no-Renderer-
       exists case, and only after that finishes, to call Renderer
       convertClientId() to transform the ID into a proper form for output:

	Renderer renderer = getRenderer();
	if (renderer != null) {
	  clientId = renderer.convertClientId(context, clientId);
	}

	   * <p>Return a client-side identifier for this component, generating
     +     * one if necessary.  The associated {@link
     +     * javax.faces.render.Renderer}, if present, will be asked to
     +     * convert the clientId to a form suitable for transmission to the
     +     * client.</p>

     - change setId()

     6. Spec setId() to throw IllegalArgumentException if either:
     - the ID contains NamingContainer.SEPARATOR_CHAR
     - the ID begins with UIViewRoot.UNIQUE_ID_PREFIX

	   *
	   * @param id The new component identifier
	   *
     +     * @exception IllegalArgumentException if <code>id</code> is zero
     +     * length, begins with {@link NamingContainer#SEPARATOR_CHAR}, or
     +     * {@link UIViewRoot#UNIQUE_ID_PREFIX}, or contains invalid
     +     * characters

     4. Rewrite UIComponentBase.findComponent() as a brute force search.
       Change UIComponent.findComponent()'s spec to read as follows:

       /**
	* Searches for a component with a matching ID.  The search will
	* begin either from the root of the component tree or the
	* nearest ancestor NamingContainer, whichever is closer, and
	* continue recursively through all children and facets, but will not
	* continue inside any NamingContainers.
	* <p>
	* If this component is itself a NamingContainer, the search will
	* first recursively search children and facets inside of the component,
	* then search from the root of the component tree or the
	* nearest ancestor NamingContainer, whichever is closer.
	* <p>
	* If the ID contains instances of NamingContainer.SEPARATOR_CHAR,
	* then the call is treated as a request for a recursive search.
	* The ID will be divided into a series of IDs separated by
	* NamingContainer.SEPARATOR_CHAR, reading from left to right.
	* The search begins as above, but will instead search for a component
	* matching the first ID.  If that search suceeds, findComponent()
	* will search recursively all children and facets inside of that
	* component for a descendant matching the second ID; etc.
	* If any step of the search fails, findComponent() returns null
	* (and does not throw an exception).
	*/

     M src/javax/faces/component/UIComponentBase.java

     - new findComponent implementation.

     - new setId implementation

     - remove all traces of naming container interaction from the children
       inner List impl.

     M src/javax/faces/component/UIForm.java

     - no longer implements NamingContainer.

     R src/javax/faces/component/UINamingContainer.java

     - no longer needed

     M src/javax/faces/component/UIViewRoot.java

     - no longer implements NamingContainer.

     M src/javax/faces/render/Renderer.java

     11. Change Renderer.getClientId(FacesContext context) to
     Renderer.convertClientId(FacesContext context, String clientId)
     with the following default implementation

     public String convertClientId(FacesContext context, String clientId)
     {
	return clientId;
     }

   


SECTION: Spec document changes:

  [JSFA120] Implement spec changes related to event bubbling changes.

    * [2.2.2 ... 2.2.5] -- Refine the lifecycle phase descriptions to document
      that event broadcasting is performed by the processXxx method of
      the UIViewRoot instance at the root of the component tree.

    * [2.3] -- Refine overall description of the Common Event Processing
      to match the new behavior factoring.

    * [3.1.10] -- Document the new UIComponent.queueEvent() method.

    * [6.1.6] -- Remove FacesContext.addFacesEvent() and
      getFacesEvents().

    * Further [JSFA120] related commit (document updated behavior of
      UIViewRoot) plus some cosmetic changes.  Impact analysis for all
      of [JSFA120] was in the previous spec commit message.

    * [JSFA120] Ensure that an ANY_PHASE listener sees any single event
      once, instead of once per phase in the case where there are
      listeners registered for later phases explicitly.

    * [JSFA120] Correct implementation of event queueing so that we
      won't see ConcurrentModificationException errors if new events are
      queued while the existing ones are being processed.  Essentially,
      this required simulating an Iterator.

    RI IMPACTS:

    * Any renderer whose decode method needs to queue events must call the
      queueEvent() method on the source UIComponent, instead of calling
      the removed FacesContext.addFacesEvent() method.

    * FacesContextImpl - remove event queue functionality.

    * LifecycleImpl - remove event broadcasting functionality, which is now
      handled by UIViewRoot.  Add call to
      UIViewRoot.processApplication() during Invoke Application phase.

   JSFA3, JSFA101, JSFA110, JSFA76

   3.1.1 

     New rules for component id validitiy

   3.2.2 

     Emasculate this section, since NamingContainer has no more PME.

   3.1.6

     New description of find component

   4.1.4.{2,3,4}, 4.1.15.{2,3,4}

     No methods on NamingContainer

   6.1.2

     Remove ExternalContext.encodeURL().

   10.3.3.

     Import current DTD.

   8.6

     New section documenting the concrete HTML component classes.

   JSFA76/JSFA104

   4.1.4.

     Fix assertion to say that the form Renderer must call writeState.

   4.1.4.3

     Document new methods:

     public boolean isSubmitted();

     public void setSubmitted(boolean submitted);

     public void processDecodes(FacesContext context) throws IOException;

     public void processValidators(FacesContext context);

     public void processUpdates(FacesContext context);

   8.5.3 

     Document the new requirements on FormRenderer.

   4.1.4.3 

     Spec assertion to cause the UIForm to call setSubmitted(false) from
     its saveState().

   JSFA121

     SECTION 11.1.  Note that you can add cause a PhaseListener to be added
     by making an entry in the faces-config.xml file.

     RI Impact:

     Need to modify digester rules such that the <phase-listener> element 
     causes Lifecycle.addPhaseListener() to be called.

   JSFA119

     RI IMPACT: Make sure that the RI never ever uses the presence of
     messages in the FacesContext as a cue for skipping to render response.

     2.2.3

       Removed text that talks about using the presence of Messages as a cue
       for skipping to Render Response Phase.

     RI Impact: I think this will break some of our lifecycle tests.
     Also, I think we're going to want to change the exception we catch
     in UpdateModelValuesPhase to be RuntimeException.

     sections 2.2.3, 2.2.4, 3.1.11

     - Spec that if a RuntimeException is thrown during decode, validation,
       or update model processing, it is caught, renderResponse() is
       called, and the exception is re-thrown.



SECTION: RI Changes: 150 commit messages

Known Issues With This Release
==============================

Legal Notice
============

Copyright © 2002 Sun Microsystems, Inc., 4150 Network Circle, Santa
Clara, California 95054, U.S.A. All rights reserved.

Sun Microsystems, Inc. has intellectual property rights relating to
technology embodied in this product. In particular, and without
limitation, these intellectual property rights may include one or more
of the U.S. patents listed at http://www.sun.com/patents and one or more
additional patents or pending patent applications in the U.S. and other
countries.

This product is distributed under licenses restricting its use, copying
distribution, and decompilation. No part of this product may be
reproduced in any form by any means without prior written authorization
of Sun and its licensors, if any.

Third-party software, including font technology, is copyrighted and
licensed from Sun suppliers.

Sun, Sun Microsystems, the Sun logo, the Java Coffee Cup logo,
JavaServer, and Java are trademarks or registered trademarks of Sun
Microsystems, Inc. in the U.S. and other countries.

Federal Acquisitions: Commercial Software - Government Users Subject to
Standard License Terms and Conditions.

-----------------------------------------------------------------------

Copyright © 2002 Sun Microsystems, Inc., 4150 Network Circle,
Santa Clara, California 95054, Etats-Unis. Tous droits réservés.

Sun Microsystems, Inc. a les droits de propriété intellectuels relatants
à la technologie incorporée dans ce produit. En particulier, et sans la
limitation, ces droits de propriété intellectuels peuvent inclure un ou
plus des brevets américains énumérés à http://www.sun.com/patents et un
ou les brevets plus supplémentaires ou les applications de brevet en
attente dans les Etats - Unis et les autres pays.

Ce produit ou document est protégé par un copyright et distribué avec
des licences qui en restreignent l'utilisation, la copie, la
distribution, et la décompilation. Aucune partie de ce produit ou
document ne peut être reproduite sous aucune forme, par quelque moyen
que ce soit, sans l'autorisation préalable et écrite de Sun et de ses
bailleurs de licence, s'il y ena.

Le logiciel détenu par des tiers, et qui comprend la technologie
relative aux polices de caractères, est protégé par un copyright et
licencié par des fournisseurs de Sun.

Sun, Sun Microsystems, le logo Sun, le logo Java Coffee Cup, JavaServer,
et Java sont des marques de fabrique ou des marques déposées de Sun
Microsystems, Inc. aux Etats-Unis et dans d'autres pays.
